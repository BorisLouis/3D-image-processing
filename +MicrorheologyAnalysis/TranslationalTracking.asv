classdef TranslationalTracking < handle

    properties
        raw
        info
        Traces
        Results
        Stepsizes
        PopulationFractions
        ResultsStepsize
    end
    
    methods
        function obj = TranslationalTracking(Path, info)
            obj.raw.Path = Path;
            obj.info = info;
        end

        function LoadTraces(obj, Filename)
            f2Load = append(obj.raw.Path, filesep, Filename, '.mat');
            tmpData = load(f2Load);
            name = fieldnames(tmpData);
            data = tmpData.(name{1});

            if ~or(isnan(obj.info.CutTraces), obj.info.CutTraces == 0)
                if isfield(data, 'traces')
                    data = data.traces;
                end

                if size(data, 2) < size(data, 1)
                    data = data';
                end
                mSizes = cellfun(@(t) size(t,1), data(1,:));
                mask = mSizes > obj.info.MinSize;
                data = data(:,mask)';

                Length = obj.info.CutTraces;
                f = waitbar(0, 'initializing');
                for step = 1:max([data{end,1}.t])-Length
                    waitbar(step./(max([data{end,1}.t])-Length), f, append('Cutting traces - Frame ', num2str(step), '/', num2str(max([data{end,1}.t])-Length)))
                    CurrTraceCell = {};
                    for i = 1:size(data,1)
                        CurrTrace = data{i,1};
                        CurrTraceCutted = CurrTrace(ismember(CurrTrace.t, (step:(step+Length))), :);    
                        if ~isempty(CurrTraceCutted)
                            if strcmp(obj.info.StepsizeAnalysis, 'on')
                                CurrTraceCell{end+1,1} = CurrTraceCutted;
                            else
                                if size(CurrTraceCutted, 1) > obj.info.MinSize
                                    CurrTraceCell{end+1,1} = CurrTraceCutted;
                                end
                            end
                        end
                    end
                    dataMatrix{step, 1} = CurrTraceCell;
                end
                close(f)
            else
                try
                    Data = data.traces;
                catch
                    Data = data;
                end
                mSizes = cellfun(@(t) size(t,1), Data(1,:));
                mask = mSizes > obj.info.MinSize;
                Data = Data(:,mask)';
                dataMatrix{1, 1} = Data;
            end
            obj.Traces = dataMatrix;
        end

        function TracesAnalysis(obj, Radius, Loop)
             
            run = 1;
            if run == 0 
                obj.Results = Results;
            elseif run == 1
                nRows = size(obj.Traces, 1);

                try
                    MinIdx = strfind(obj.raw.Path, 'min');
                    TimeStamp = obj.raw.Path(MinIdx+3:MinIdx+4);
                    TimeStamp = str2num(erase(TimeStamp, '_'));
                catch
                    TimeStamp = 0;
                end
    
                Time     = nan(nRows, 1);
                DiffMean = nan(nRows, 1);
                DiffStd  = nan(nRows, 1);
                ViscMean = nan(nRows, 1);
                ViscStd  = nan(nRows, 1);
                AnExpMean = nan(nRows, 1);
                AnExpStd  = nan(nRows, 1);
                DiffAll = cell(nRows, 1);
                ViscAll = cell(nRows, 1);
                AnExpAll = cell(nRows, 1);
                TimeResults = table(Time, DiffMean,DiffStd,DiffAll,ViscMean, ViscStd, ViscAll,AnExpMean,AnExpStd,AnExpAll);
    
                f = waitbar(0, 'initializing');
                for k = 1:nRows
                    currMov = obj.Traces{k, 1};
                    AllStepSizes = [];
                    if ~isempty(currMov)
                        allRes = struct('msdx',0,'msdy',0,'msdz',0,'msdr',0,'tau',0,'DX',0,'DY',0,'DZ',0,'DR',0,...
                            'nX',0,'nY',0,'nZ',0,'nR',0,'aX',0,'aY',0,'aZ',0,'aR',0,'vX',0,'vY',0,...
                            'vZ',0,'vR',0,'Gcomplex_x', 0, 'Gcomplex_y', 0, 'Gcomplex_z', 0, 'Gcomplex_r', 0,...
                            'Gloss_x', 0, 'Gloss_y', 0, 'Gloss_z', 0, 'Gloss_r', 0,...
                            'Gstorage_x', 0, 'Gstorage_y', 0, 'Gstorage_z', 0, 'Gstorage_r', 0, 'RoG_x', 0,...
                            'RoG_y', 0, 'RoG_z', 0', 'RoG_r', 0,...
                            'RoGTensor_x', 0, 'RoGTensor_y', 0, 'RoGTensor_z', 0, 'RoGTensor_r', 0,...
                            'Lp_x', 0, 'Lp_y', 0, 'Lp_z', 0, 'Lp_r', 0,...
                            'EndToEnd_x', 0, 'EndToEnd_y', 0, 'EndToEnd_z', 0, 'EndToEnd_r', 0,...
                            'num', 0);
                        if strcmp(obj.info.Experiment, 'Tracking-Segmentation')
                            allRes.Mask = 0;
                        elseif strcmp(obj.info.Experiment, 'Tracking-Phase')
                            allRes.Phase = 0;
                        end
                        allRes(length(currMov)).msdX = [];
                        maxLength = max(cellfun(@height, currMov(:,1)));
    
                        for i = 1:length(currMov)
                            waitbar(i./length(currMov), f, append('Microrheology analysis - part ', num2str(k), '/', num2str(size(obj.Traces, 1))));
                            currPart = currMov{i};
                        
                            coordinates = [currPart.col, currPart.row, currPart.z];
                            CM = mean(coordinates,1);
                            coordinates = coordinates-CM;
                        
                            %in X
                            coord = coordinates(:,1)/10^3;
                            Dimension = '1D';
                            [~, allRes(i).msdx, allRes(i).tau, allRes(i).DX, allRes(i).nX, allRes(i).aX, allRes(i).vX] = obj.TraceAnalysis(coord, Dimension, Radius);
                            [allRes(i).Gcomplex_x, allRes(i).Gstorage_x, allRes(i).Gloss_x] = obj.PassiveMicrorheology(allRes(i).msdx, allRes(i).tau, Radius, 0.5);
                            [allRes(i).RoGTensor_x, allRes(i).RoG_x] = obj.GyrationTensor(coord);
                            [allRes(i).Lp_x, allRes(i).EndToEnd_x] = obj.PersistenceLength(coord);

                            %in Y
                            coord = coordinates(:,2)/10^3;
                            Dimension = '1D';
                            [~, allRes(i).msdy, ~, allRes(i).DY, allRes(i).nY, allRes(i).aY, allRes(i).vY] = obj.TraceAnalysis(coord, Dimension, Radius);
                            [allRes(i).Gcomplex_y, allRes(i).Gstorage_y, allRes(i).Gloss_y] = obj.PassiveMicrorheology(allRes(i).msdy, allRes(i).tau, Radius, 0.5);
                            [allRes(i).RoGTensor_y, allRes(i).RoG_y] = obj.GyrationTensor(coord);
                            [allRes(i).Lp_y, allRes(i).EndToEnd_y] = obj.PersistenceLength(coord);

                            %inZ
                            if strcmp(obj.info.Dimension, '3D')
                                coord = coordinates(:,3)/10^3;
                                Dimension = '1D';
                                [~, allRes(i).msdz, ~, allRes(i).DZ, allRes(i).nZ, allRes(i).aZ, allRes(i).vZ] = obj.TraceAnalysis(coord, Dimension, Radius);
                                [allRes(i).Gcomplex_z, allRes(i).Gstorage_z, allRes(i).Gloss_z] = obj.PassiveMicrorheology(allRes(i).msdz, allRes(i).tau, Radius, 0.5);
                                [allRes(i).RoGTensor_z, allRes(i).RoG_z] = obj.GyrationTensor(coord);
                                [allRes(i).Lp_z, allRes(i).EndToEnd_z] = obj.PersistenceLength(coord);
                            else
                                allRes(i).msdz = [];
                                allRes(i).DZ = NaN;
                                allRes(i).nZ = NaN;
                                allRes(i).aZ = NaN;
                                allRes(i).vZ = NaN;
                                allRes(i).Gcomplex_z = [];
                                allRes(i).Gloss_z = [];
                                allRes(i).Gstorage_z = [];
                                allRes(i).RoGTensor = [];
                                allRes(i).RoG = NaN;
                                allRes(i).Lp_z = NaN;
                                allRes(i).EndToEnd_z = NaN;
                            end
    
                            %inR
                            if strcmp(obj.info.Dimension, '3D')
                                coord = coordinates(:,1:3)/10^3;
                                Dimension = '3D';
                            elseif strcmp(obj.info.Dimension, '2D')
                                coord = coordinates(:,1:2)/10^3;
                                Dimension = '2D';
                            end          
                            [~, allRes(i).msdr, ~, allRes(i).DR, allRes(i).nR, allRes(i).aR, allRes(i).vR] = obj.TraceAnalysis(coord, Dimension, Radius);
                            [allRes(i).Gcomplex_r, allRes(i).Gstorage_r, allRes(i).Gloss_r] = obj.PassiveMicrorheology(allRes(i).msdr, allRes(i).tau, Radius, 0.5);
                            [allRes(i).RoGTensor_r, allRes(i).RoG_r] = obj.GyrationTensor(coord);
                            [allRes(i).Lp_r, allRes(i).EndToEnd_r] = obj.PersistenceLength(coord);
    
                            allRes(i).num  = length(allRes(i).msdr);
                    
                            % if strcmp(obj.info.Experiment, 'Tracking-Segmentation')
                            %     allRes(i).Mask = round(mean(currPart.InSegment));
                            % elseif strcmp(obj.info.Experiment, 'Tracking-Phase')
                            %     try
                            %         allRes(i).Phase = nanmean(currPart.Phase);
                            %         allRes(i).IntPhaseCh = nanmean(currPart.IntPhaseCh);
                            %         allRes(i).GradientMagnitude = nanmean(currPart.GradientMagnitude);
                            %         allRes(i).LocalVariance = nanmean(currPart.LocalVariance);
                            %         allRes(i).SharpnessLaplacian = nanmean(currPart.SharpnessLaplacian);
                            %     catch
                            %         allRes(i).Phase = NaN;
                            %         allRes(i).IntPhaseCh = NaN;
                            %         allRes(i).GradientMagnitude = NaN;
                            %         allRes(i).LocalVariance = NaN;
                            %         allRes(i).SharpnessLaplacian = NaN;
                            %     end
                            % end
                        end
    
                        disp(['The diffusion coefficient is ', num2str(mean([allRes.DR], 'omitnan')), ' \mum^2/s and the viscosity is ', num2str(mean([allRes.nR], 'omitnan')), ' cp']);
    
                        % TimeResults.Time(k) = TimeStamp + k*obj.info.expTime;
                        % TimeResults.DiffMean(k) = mean([allRes.DR]); 
                        % TimeResults.DiffStd(k)  = std([allRes.DR]);
                        % TimeResults.ViscMean(k) = mean([allRes.nR]);
                        % TimeResults.ViscStd(k)  = std([allRes.nR]);
                        % TimeResults.AnExpMean(k) = mean([allRes.aR]);
                        % TimeResults.AnExpStd(k)  = std([allRes.aR]);
                        % TimeResults.DiffAll{k} = [allRes.DR];
                        % TimeResults.ViscAll{k} = [allRes.nR];
                        % TimeResults.AnExpAll{k} = [allRes.aR];  
                    else
                        disp(append('No traces found that are longer than MinSize (', num2str(MinSize), ' datapoints)'))
                        TimeResults.Time(k) = k;
                    end
    
                    Results{k,1} = allRes;
                    % Results{k,2} = TimeResults;
                end
                obj.Results{Loop, 1} = Results;
                filename = append(obj.raw.Path, filesep, 'msdRes_traceAnalysis', num2str(Loop), '.mat');
                save(filename, "Results");
                Results{end,2} = TimeResults;
                % obj.Results{Loop, 1} = Results;
                % filename = append(obj.raw.Path, filesep, 'msd_TimeResults_traceAnalysis', num2str(Loop), '.mat');
                % save(filename, "TimeResults");
            end
        end

        function PlotTrends(obj)
            fig = figure;
            baseColors = [0.8500 0.3250 0.0980; 0.4660 0.6740 0.1880];
            for i = 1:size(obj.Results, 1)
                try  
                    Data = obj.Results{i,1}{end,2};
                    Data(isnan([Data.Time]),:) = [];
                    Time = Data.Time;
                    DiffMean = Data.DiffMean;
                    DiffStd = Data.DiffStd; 

                    baseColor = baseColors(i, :);  % MATLAB default blue
                    lighterColor = baseColor + 0.5 * (1 - baseColor); % lighter for shading

                    upper = DiffMean + DiffStd;
                    lower = DiffMean - DiffStd;

                    hold on;
                    fill([Time; flipud(Time)], ...
                         [upper; flipud(lower)], ...
                         lighterColor, ...
                         'FaceAlpha', 0.8, 'EdgeColor', 'none');
                    hold on
                    plot(Time, DiffMean, 'Color', baseColor, 'LineWidth', 2);
                catch
                end
            end
            xlabel('Time (s)', 'FontSize', 12);
            ylabel('Diffusion (µm^2/s)', 'FontSize', 12);
            grid on; box on; axis tight;
            set(gca, 'FontSize', 10);
            legend({'', append(num2str(obj.info.Radius1*100), ' nm'), '', append(num2str(obj.info.Radius2*100), ' nm')}, 'Location', 'best');
            title('Diffusion over Time');
            saveas(fig, append(obj.raw.Path, filesep, 'DiffusionTrend.png'));


            fig = figure;
            baseColors = [0.8500 0.3250 0.0980; 0.4660 0.6740 0.1880];
            for i = 1:size(obj.Results, 1)
                try  
                    Data = obj.Results{i,1}{end,2};
                    Data(isnan([Data.Time]),:) = [];
                    Time = Data.Time;
                    ViscMean = Data.ViscMean;
                    ViscStd = Data.ViscStd; 

                    baseColor = baseColors(i, :);  % MATLAB default blue
                    lighterColor = baseColor + 0.5 * (1 - baseColor); % lighter for shading

                    upper = ViscMean + ViscStd;
                    lower = ViscMean - ViscStd;

                    hold on;
                    fill([Time; flipud(Time)], ...
                         [upper; flipud(lower)], ...
                         lighterColor, ...
                         'FaceAlpha', 0.8, 'EdgeColor', 'none');
                    hold on
                    plot(Time, ViscMean, 'Color', baseColor, 'LineWidth', 2);
                catch
                end
            end
            xlabel('Time (s)', 'FontSize', 12);
            ylabel('Viscosity (cP)', 'FontSize', 12);
            grid on; box on; axis tight;
            set(gca, 'FontSize', 10);
            set(gca, 'YScale', 'log');
            legend({'', append(num2str(obj.info.Radius1*1000), ' nm'), '', append(num2str(obj.info.Radius2*1000), ' nm')}, 'Location', 'best');
            title('Viscosity over Time');
            ylim([0 50]);
            saveas(fig, append(obj.raw.Path, filesep, 'ViscosityTrend.png'));
        end

        function [AvStep, msdx, tau, D, n, a, v] = TraceAnalysis(obj, coord, Dimension, Radius)
            AvStep = MSD.getAvStepSize(coord); 
            msdx = MSD.calc(coord);%convert to um;
            tau = (1:length(msdx))'*obj.info.expTime;
            D  = MSD.getDiffCoeff(msdx,tau,obj.info.DiffFit,Dimension);
            n  = MSD.getViscosity(D,Radius,obj.info.Temp);
            a  = MSD.getDiffTypeAlpha2(msdx,obj.info.expTime, AvStep);
            if strcmp(Dimension, '1D')
                v  = abs(coord(1,1) - coord(end,1)/10^3/(length(coord)*obj.info.expTime)); %um/s
            elseif strcmp(Dimension, '3D')
                d   = sqrt((coord(1,1)-coord(end,1))^2 + (coord(1,2)-coord(end,2))^2 + (coord(1,3)-coord(end,3))^2);
                v = d/(length(coord)*obj.info.expTime); %um/s
            elseif strcmp(Dimension, '2D')
                d   = sqrt((coord(1,1)-coord(end,1))^2 + (coord(1,2)-coord(end,2))^2);
                v = d/(length(coord)*obj.info.expTime); %um/s
            end
        end

        function PlotDistributions(obj, Loop)
            m = size(obj.Results{Loop,1},1);
            DR_all = cell(m,1);
            allDR = []; 
            for i = 1:m
                if strcmp(obj.info.StepsizeAnalysis, 'on')
                    StepMatrix = (obj.Results{Loop,1}{end,2}.AllStepSizes{i,1}(:,1)).^2./obj.info.expTime;
                    DR_all{i} = StepMatrix(:);
                    allDR = [allDR; StepMatrix];
                else
                    DR = [obj.Results{Loop,1}{i,1}.DR];
                    DR_all{i} = DR(:);      % ensure column vector
                    allDR = [allDR, DR];
                end
            end
            lowEdge  = 0;     % lower bound: 1st percentile
            highEdge = 10;    % upper bound: 99th percentile

            numBins = 50;                     % adjust as needed
            edges = linspace(lowEdge, highEdge, numBins+1);
            binCenters = edges(1:end-1) + diff(edges)/2;
            H = zeros(m, numBins);

            for t = 1:m
                H(t,:) = histcounts(DR_all{t}, edges);
            end

            Fig = figure;
            surf(binCenters, [1:m].*obj.info.expTime, H, 'EdgeColor', 'none');
            view(2); % optional: use view(3) for perspective
            
            xlabel('Diffusion coefficient (µm^2/s)');
            ylabel('Time (s)');
            zlabel('Counts (abs)');
            a=colorbar;
            a.Label.String = 'Counts (abs)';
            title(append('Diffusion coefficient over time - ', num2str(1000*obj.info.(append('Radius', num2str(Loop)))), ' nm'));

            if strcmp(obj.info.StepsizeAnalysis, 'on')
                title(append('Diffusion coefficient over time (1st order stepsize) - ', num2str(1000*obj.info.(append('Radius', num2str(Loop)))), ' nm'));
                saveas(Fig, append(obj.raw.Path, filesep, 'DistributionPlot_Diffusion_Stepsize', num2str(Loop), '.png'));
            else
                saveas(Fig, append(obj.raw.Path, filesep, 'DistributionPlot_Diffusion', num2str(Loop), '.png'));
            end
        end

        function [Gmag, Gp, Gpp] = PassiveMicrorheology(obj, msd, tau, Radius, fracKeep)
            nPts = numel(msd);
            nKeep = max(5, round(fracKeep*nPts));
            msd = msd(1:nKeep);
            tau = tau(1:nKeep);

            logTau = log10(tau);
            logMSD = log10(msd);
            windowLength = min(11, numel(tau)); % must be odd, <= number of points
            if mod(windowLength,2)==0
                windowLength = windowLength-1; % make odd
            end
            polyOrder = 2;
            smoothLogMSD = sgolayfilt(logMSD, polyOrder, windowLength);
            alpha = gradient(smoothLogMSD) ./ gradient(logTau);
            alpha(alpha < 0) = 0;
            alpha(alpha > 1) = 1;
            
            % complex modulus magnitude (Mason–Weitz GSER)
            Gmag = (1.3806498*10^(-23)*obj.info.Temp) ./ (pi*Radius*10^(-9)*msd*10^-(12) .* gamma(1+alpha));
            
            % storage and loss moduli
            Gp  = Gmag .* cos(pi*alpha/2);
            Gpp = Gmag .* sin(pi*alpha/2);
        end

        function [G, Rg] = GyrationTensor(obj, coords)
            [N, d] = size(coords);
            if d < 1 || d > 3
                error('coords must be an n×1, n×2, or n×3 matrix.');
            end

            r_mean = mean(coords, 1);
            R = coords - r_mean;
            G = (R' * R) / N;
            Rg = sqrt(trace(G));
        end

        function [Lp, Re] = PersistenceLength(obj, coords)
            % PersistenceLength estimates the persistence length of a polymer-like
            % trace using the tangent–tangent correlation method -
            % Worm-like chain model
     
            [N, d] = size(coords);
            if d < 1 || d > 3
                error('coords must be n×1, n×2, or n×3');
            end

            % --- Compute tangent vectors ---
            dr = diff(coords, 1, 1);            % segment vectors
            segLengths = sqrt(sum(dr.^2, 2));   % segment lengths
            t = dr ./ segLengths;               % normalized tangents (N-1 x d)
        
            % arc-length step (mean step length)
            ds = mean(segLengths);
        
            % --- Tangent-tangent correlation function ---
            maxLag = floor((N - 1) / 2);   % enough statistics
        
            C = zeros(maxLag,1);
            s = (1:maxLag)' * ds;          % separation distances
        
            for k = 1:maxLag
                dots = sum(t(1:end-k,:) .* t(1+k:end, :), 2);
                C(k) = mean(dots);
            end
        
            % --- Fit C(s) = exp(-s / Lp) using linear regression on ln(C) ---
            % Only use positive values of C for log
            valid = C > 0.05;  % threshold removes noise
        
            if sum(valid) < 3
                Lp = NaN;
            else
                y = log(C(valid));
                x = s(valid);
            
                % linear fit: ln(C) = -s/Lp
                xm = mean(x);
                ym = mean(y);
                slope = sum((x - xm) .* (y - ym)) / sum((x - xm).^2);
                Lp = -1 / slope;
            
                Lp = -1 / slope;    % persistence length
            end
        
            % --- End-to-end distance ---
            Re = norm(coords(end,:) - coords(1,:));
        
        end

        function [StepSizes] = GetStepSizes(obj, coords)
            [N, d] = size(coords);
            stepVectors = diff(coords, 1, 1);   % (N-1 × d)
            StepSizes = NaN(N, N-1);
            for tau = 1
                StepSizeList = [];
                for start = 1:tau
                    IdxList = [1:N]+(start-1);
                    idx = mod(IdxList, tau) == 0;
                    SelectedCoords = coords(idx, :);
                    stepVectors = diff(SelectedCoords,1,1);
                    StepSizeList = [StepSizeList; sqrt(sum(stepVectors.^2, 2))];
                end
                StepSizes(1:size(StepSizeList, 1), tau) = StepSizeList;
            end
        end

        function CalculateStepsizes(obj,Loop)
            run = 1;

            if run == 0 
                obj.Results = Results;
            elseif run == 1
                nRows = size(obj.Traces, 1);

                
                allRes = struct('StepSizes_x',0,'StepSizes_y',0,'StepSizes_z',0,'StepSizes_r',0);
    
                f = waitbar(0, 'initializing');
                for k = 1:nRows
                    currMov = obj.Traces{k, 1};
                    AllStepSizes = [];
                    if ~isempty(currMov)
                        maxLength = max(cellfun(@height, currMov(:,1)));
    
                        for i = 1:length(currMov)
                            if nRows == 1
                                waitbar(i./length(currMov), f, append('Calculating stepsizes - trace ', num2str(i), '/', num2str(length(currMov))));
                            else
                                waitbar(i./length(currMov), f, append('Calculating stepsizes - part ', num2str(k), '/', num2str(size(obj.Traces, 1))));
                            end
                            currPart = currMov{i};
                        
                            coordinates = [currPart.col, currPart.row, currPart.z];
                            CM = mean(coordinates,1);
                            coordinates = coordinates-CM;
                        
                            %in X
                            coord = coordinates(:,1)/10^3;
                            Dimension = '1D';
                            [allRes(i).StepSizes_x] = obj.GetStepSizes(coord);

                            %in Y
                            coord = coordinates(:,2)/10^3;
                            Dimension = '1D';
                            [allRes(i).StepSizes_y] = obj.GetStepSizes(coord);
                            
                            %inZ
                            if strcmp(obj.info.Dimension, '3D')
                                coord = coordinates(:,3)/10^3;
                                Dimension = '1D';
                                [allRes(i).StepSizes_z] = obj.GetStepSizes(coord);
                            end
    
                            %inR
                            if strcmp(obj.info.Dimension, '3D')
                                coord = coordinates(:,1:3)/10^3;
                                Dimension = '3D';
                            elseif strcmp(obj.info.Dimension, '2D')
                                coord = coordinates(:,1:2)/10^3;
                                Dimension = '2D';
                            end          
                            [allRes(i).StepSizes_r] = obj.GetStepSizes(coord);
                    
                            if all(size(AllStepSizes) == [0 0])
                                AllStepSizes = [AllStepSizes; allRes(i).StepSizes_r];
                            elseif size(AllStepSizes, 2) > size(allRes(i).StepSizes_r, 2)
                                ToAdd = [allRes(i).StepSizes_r, nan(size(allRes(i).StepSizes_r,1), size(AllStepSizes, 2) - size(allRes(i).StepSizes_r, 2))];
                                AllStepSizes = [AllStepSizes; ToAdd];
                            elseif size(AllStepSizes, 2) < size(allRes(i).StepSizes_r, 2)
                                ToAdd = [AllStepSizes, nan(size(AllStepSizes,1), size(allRes(i).StepSizes_r, 2) - size(AllStepSizes, 2))];
                                AllStepSizes = [ToAdd; allRes(i).StepSizes_r];
                            else
                                AllStepSizes = [AllStepSizes; allRes(i).StepSizes_r];
                            end
                        end
 
                        TimeResults.AllStepSizes{k} = AllStepSizes;
                    else
                        TimeResults.Time(k) = k;
                    end
    
                    Results{k,1} = allRes;
                end
                close(f)
                obj.Results{Loop, 1} = Results;
                filename = append(obj.raw.Path, filesep, 'msdRes_stepsizeAnalysis', num2str(Loop), '.mat');
                save(filename, "Results");
                Results{end,2} = TimeResults;
                obj.Stepsizes{Loop, 1} = Results;
                filename = append(obj.raw.Path, filesep, 'msd_TimeResults_stepsizeAnalysis', num2str(Loop), '.mat');
                save(filename, "TimeResults");
            end
        end

        function FitDiffPopulations(obj, Loop)
            dt = obj.info.expTime;
            nRows = size(obj.Traces, 1);
            nI = numel(nRows);   
            Kmax = 3;           

            OutputFolder = append(obj.raw.Path, filesep, 'ecdf_fits_channel', num2str(Loop));
            mkdir(OutputFolder);
            Results = obj.Stepsizes{1,1};  

            try
                MinIdx = strfind(obj.raw.Path, 'min');
                MaxIdx = strfind(obj.raw.Path, '_sample');
                TimeStamp = obj.raw.Path(MinIdx+3:MaxIdx-1);
                TimeStamp = str2num(erase(TimeStamp, '_'));
            catch
                TimeStamp = 0;
            end

            f = waitbar(0, 'Initializing');
            for K = 1:3
                OutputFolder2 = append(OutputFolder, filesep, 'FitPopulations', num2str(K));
                mkdir(OutputFolder2);

                I = nan([size(Results{end, 2}.AllStepSizes, 2),1]);
                BIC = nan([size(Results{end, 2}.AllStepSizes, 2),1]);
                D = nan([size(Results{end, 2}.AllStepSizes, 2),K]);
                w = nan([size(Results{end, 2}.AllStepSizes, 2),K]);
                N = nan([size(Results{end, 2}.AllStepSizes, 2),1]);

                nRows = size(Results{end, 2}.AllStepSizes, 2);

                for i = 1:size(Results{end, 2}.AllStepSizes, 2)
                    try
                        waitbar(i./nI, f, append('fitting ecdf - part ', num2str(i), ' out of ', num2str(nI)));
                        r = Results{end, 2}.AllStepSizes{1,i}(:,1)';
                        if Loop == 1
                            r(r > 0.750) = [];
                        elseif Loop == 2
                            r(r > 0.450) = [];
                        end
                        r(isnan(r)) = [];
                        r = rmoutliers(r);
                        N(i,:) = numel(r);
                        [r_sorted, idx] = sort(r);
                        F_emp = (1:N(i,:))'/N(i,:);
                    
                        s = r.^2;
                        k_shape = 3/2;
    
                        gamma_pdf = @(s,theta) (1./(gamma(k_shape)*theta.^k_shape)) .* s.^(k_shape-1) .* exp(-s./theta);
                        models = struct();

                        [theta, w(i,:), logL] = obj.EM_gamma_fixedshape(s, K, 200);
                    
                        numParams = (K-1) + K; % weights + theta
                        BIC(i,1) = -2*logL(end) + numParams*log(N(i,:));
                        D(i,:) = theta ./ (4*dt);
    
                        F_mix = zeros(size(r_sorted));
                        for j = 1:K
                            F_mix = F_mix + w(i,:) * gammainc(r_sorted.^2 ./ theta, 3/2);
                        end
                        F_mix = F_mix./K;
    
                        if or(i == 1, mod(i, 100) == 0)
                            Fig = figure;
                            plot(r_sorted, F_emp, 'k.', 'DisplayName', 'Empirical');
                            hold on;
                            plot(r_sorted, F_mix, 'b-', 'LineWidth', 2, ...
                                'DisplayName', sprintf('%d-pop mixture', K));
                            xlabel('Step size r');
                            ylabel('CDF');
                            title(append('cdf fit - ', num2str(K), ' populations, timepoint ', num2str(i)))
                            grid on;
                            saveas(Fig, append(OutputFolder2, filesep, 'TimePoint', num2str(i), '.svg'));
                            saveas(Fig, append(OutputFolder2, filesep, 'TimePoint', num2str(i), '.svg'));
                        end
                        if nRows ~= 1
                            I(i, 1) = i*obj.info.expTime + TimeStamp*60;
                        else
                            TimeStamp = 0;
                            I(i, 1) = i*obj.info.expTime;
                        end
                    catch
                        I(i, 1) = i*obj.info.expTime + TimeStamp*60;
                        BIC(i,1) = nan([1,1]);
                        D(i,1:K) = nan([1,K]);
                        w(i,1:K) = nan([1,K]);
                        N(i,1) = nan([1,1]);
                    end
                end

                FitResults.I = I;
                FitResults.BIC(:,K) = BIC;
                FitResults.N = N;
                if K == 1
                    FitResults.D(:,1) = D;
                    FitResults.fractions(:,1) = w;
                elseif K == 2
                    FitResults.D(:,2:3) = D;
                    FitResults.fractions(:,2:3) = w;
                elseif K == 3
                    FitResults.D(:,4:6) = D;
                    FitResults.fractions(:,4:6) = w;
                end
                close all

                if nRows ~= 1
                    colors = lines(Kmax);
                    Fig = figure; 
                    hold on;
                    Time = FitResults.I;
                    for Pop = 1:K
                        Dk = FitResults.D(:,Pop);
                        ak = FitResults.fractions(:,Pop);
                        scatter(Time,  Dk, 'filled', 'MarkerFaceAlpha', 'flat', 'AlphaData', ak);
                        plot(Time,  medfilt1(Dk, 50), 'Color', 'k', 'LineWidth', 2)
                    end
                    title(append('Diffusion ', num2str(K), ' populations'))
                    xlabel('Polymerisation Time (s)')
                    ylabel('Diffusion coefficient (µm^2/s)')
                    saveas(Fig, append(OutputFolder2, filesep, 'DiffusionTrend.png'))
                    saveas(Fig, append(OutputFolder2, filesep, 'DiffusionTrend.svg'))
                end
            end
            close(f);

            if nRows ~= 1
                [~, SelectPopRaw] = min(FitResults.BIC, [], 2);
                SelectPop = SelectPopRaw;
                SelectPop(SelectPop == 3) = 2;
                SelectPop = round(medfilt1(SelectPop,50));
                Start2Pop = find(SelectPop == 2, 1, 'first');
                Start2PopTime = Time(Start2Pop);
    
                Fig2 = figure();
                subplot(2,1,1)
                plot(Time, FitResults.BIC)
                ylabel('BIC score per population')
                xlabel('Polymerisation Time (s)')
                legend({'1-num Pop', '2-num Pop', '3-num Pop'}, 'Location', 'Best')
                subplot(2,1,2)
                scatter(Time, SelectPopRaw, 1, 'color', 'b', 'MarkerFaceAlpha', 0.3);
                hold on
                plot(Time, SelectPop, 'Color', 'k');
                ylim([0 4])
                ylabel('Population of preference')
                xlabel('Polymerisation Time (s)')
                sgtitle('Evaluation of population fits')
                saveas(Fig2, append(OutputFolder, filesep, 'FitEvaluations.png'))
                saveas(Fig2, append(OutputFolder, filesep, 'FitEvaluations.png'))
    
                ToPlot(1:Start2Pop, 1) = FitResults.D(1:Start2Pop, 1);
                ToPlot(1:Start2Pop, 2) = nan([Start2Pop, 1]);
                ToPlot(Start2Pop:size(FitResults.D, 1), 1:2) = fliplr(FitResults.D(Start2Pop:end, 2:3));
                Alpha(1:Start2Pop, 1) = ones([Start2Pop, 1]);
                Alpha(1:Start2Pop, 2) = zeros([Start2Pop, 1]);
                Alpha(Start2Pop:size(FitResults.D, 1), 1:2) = fliplr(FitResults.fractions(Start2Pop:end, 2:3));
                Alpha(isnan(Alpha)) = 0;
    
                Fig3 = figure;
                hold on
                subplot(5,1, [1,3])
                for Pop = 1:size(ToPlot, 2)
                    scatter(FitResults.I, ToPlot(:,Pop), 5, 'filled', 'MarkerFaceAlpha', 'flat', 'AlphaData', Alpha(:,Pop));
                    LegendNames{Pop} = append('Population ', num2str(Pop));
                    hold on
                end
                ylabel('Diffusion coefficient (µm^2/s)');
                xline(Start2PopTime);
                legend(LegendNames);
                title('Diffusion trend')
                hold on
                subplot(5,1,4)
                for Pop = 1:size(ToPlot, 2)
                    plot(FitResults.I', Alpha(:,Pop));
                    LegendNames{Pop} = append('Population ', num2str(Pop));
                    hold on
                end
                ylabel('Fractions');         
                hold on
                subplot(5,1,5)
                plot(FitResults.I, FitResults.N)
                ylabel('Number of steps')
                xlabel('Polymerisation Time (s)')
                saveas(Fig3, append(OutputFolder, filesep, 'DiffusionTrend.png'))
                saveas(Fig3, append(OutputFolder, filesep, 'DiffusionTrend.svg'));
            else 
                nRow = 0;
                disp(append('Diffusion is ', num2str(FitResults.D(1,1)), ' µm^2/s'));
            end

            obj.PopulationFractions = FitResults;
                 FitResults.Start2Pop = Start2PopTime;
            FitResults.BIC = array2table(FitResults.BIC, 'VariableNames', {'Pop1','Pop2','Pop3'});
            FitResults.D = array2table(FitResults.D, 'VariableNames', {'Pop1', 'Pop2_1','Pop2_2','Pop3_1','Pop3_2','Pop3_3'});
            FitResults.fractions = array2table(FitResults.fractions, 'VariableNames', {'Pop1','Pop2_1','Pop2_2', 'Pop3_1','Pop3_2','Pop3_3'});
            obj.ResultsStepsize = FitResults;
            save(append(obj.raw.Path, filesep, 'StepSizeResults_Channel', num2str(Loop), '.mat'), "FitResults");
        end

        function [p_fit] = FitPopulationFractions(obj, Loop)
            OutputFolder = append(obj.raw.Path, filesep, 'ecdf_fits_channel', num2str(Loop));
            % FitResults = obj.PopulationFractions;
            channel = append('ch', num2str(Loop));
            if contains(obj.raw.Path, 'bAA')
                condType = 'bAA';
            elseif contains(obj.raw.Path, 'AA')
                condType = 'AA';
            end
            if contains(obj.raw.Path, '1x_')
                condIdx = 1;
            elseif contains(obj.raw.Path, '2x_')
                condIdx = 2;
            elseif contains(obj.raw.Path, '3x_')
                condIdx = 3;
            elseif contains(obj.raw.Path, '4x_')
                condIdx = 4;
            end


            load('D:\Polymer Dynamics\3_and_6min\Results.mat');
            refDiff = DiffData.(condType)(condIdx).(channel);
            refTime = DiffData.time.sec;

            load(append(obj.raw.Path, filesep, 'StepSizeResults_Channel', num2str(Loop), '.mat'));

            [~, SelectPopRaw] = min(FitResults.BIC, [], 2);
            SelectPop = table2array(SelectPopRaw);
            SelectPop(SelectPop == 3) = 2;
            SelectPop = round(medfilt1(SelectPop,50));
            Start2Pop = find(SelectPop == 2, 1, 'first');
            Start2PopTime = FitResults.I(Start2Pop);


            ToPlot(1:Start2Pop, 1) = table2array(FitResults.D(1:Start2Pop, 1));
            ToPlot(1:Start2Pop, 2) = nan([Start2Pop, 1]);
            ToPlot(Start2Pop:size(FitResults.D, 1), 1:2) = fliplr(table2array(FitResults.D(Start2Pop:end, 2:3)));
            Alpha(1:Start2Pop, 1) = ones([Start2Pop, 1]);
            Alpha(1:Start2Pop, 2) = zeros([Start2Pop, 1]);
            Alpha(Start2Pop:size(FitResults.D, 1), 1:2) = fliplr(table2array(FitResults.fractions(Start2Pop:end, 2:3)));
            Alpha(isnan(Alpha)) = 0;

            model = @(p,x) p(1) + (p(2)-p(1))*exp(-p(3)*exp(p(4)*(x-p(5))));
            y = ToPlot(:,1);
            toRemove = isnan(y);
            x = FitResults.I;
            y(toRemove) = [];
            x(toRemove) = [];
            % 
            % y_smooth = smoothdata(y, 'sgolay', 11);
            y_smooth = medfilt1(y, 200);
            %y_smooth = y;
            x = [refTime(:); x(:)];
            y_smooth = [refDiff(:); y_smooth(:)];
            w_ref = 0; 
            w_exp = 1;
            weights = [w_ref * ones(numel(refTime),1); w_exp * ones(numel(x)-2,1)];

            a0 = min(y_smooth);
            b0 = mean(refDiff) - a0;
            c0 = 1;
            d0 = 1 / (max(x)-min(x));
            e0 = mean(x);
            p0 = [a0, b0, c0, d0, e0];
            if Loop == 1
                lb = [0.1, 0.5, 0, 0, min(x)];
                ub = [0.2, 0.7, Inf, Inf, max(x)];
            else
                lb = [0.1, 0.05, 0, 0, min(x)];
                ub = [0.2, 0.25, Inf, Inf, max(x)];
            end
            opts = optimoptions('lsqcurvefit', ...
                'Display','iter', ...
                'MaxFunctionEvaluations',5000, ...
                'FunctionTolerance',1e-12);
            weightedModel = @(p,x) sqrt(weights) .* model(p,x);
            weightedY     = sqrt(weights) .* y_smooth;
            p_fit = lsqcurvefit(model, p0, x, weightedY, lb, ub, opts);
            y_fit = model(p_fit, x);
            Fig4 = figure;
            plot(x(3:end), y, '.', 'Color',[0.7 0.7 0.7]); hold on
            plot(x(3:end), y_fit(3:end), 'b', 'LineWidth',2)
            legend('Raw data','Fit')
            xlabel('Polymerisation time (s)')
            ylabel('Diffusion coefficient (µm^2/s)')
            title('Gompertz fit - Fast diffusion fraction')
            saveas(Fig4, append(OutputFolder, filesep, 'FitFastDiff.png'))
            saveas(Fig4, append(OutputFolder, filesep, 'FitFastDiff.svg'))

       
            FitResults.Fit = array2table(p_fit, 'VariableNames', {'Base','Height','slope1', 'slope2','Inflection point'});

            obj.ResultsStepsize = FitResults;
            save(append(obj.raw.Path, filesep, 'StepSizeResults_Channel', num2str(Loop), '.mat'), "FitResults");
        end

        function StepSizeAnalysis(obj,Loop)
                
            run = 1;

            if run == 0 
                obj.Results = Results;
            elseif run == 1
                nRows = size(obj.Traces, 1);

                try
                    MinIdx = strfind(obj.raw.Path, 'min');
                    MaxIdx = strfind(obj.raw.Path, '_sample');
                    TimeStamp = obj.raw.Path(MinIdx+3:MaxIdx-1);
                    TimeStamp = str2num(erase(TimeStamp, '_'));
                catch
                    TimeStamp = 0;
                end
                allRes = struct('StepSizes_x',0,'StepSizes_y',0,'StepSizes_z',0,'StepSizes_r',0);
    
                f = waitbar(0, 'initializing');
                for k = 1:nRows
                    currMov = obj.Traces{k, 1};
                    AllStepSizes = [];
                    if ~isempty(currMov)
                        maxLength = max(cellfun(@height, currMov(:,1)));
    
                        for i = 1:length(currMov)
                            waitbar(i./length(currMov), f, append('Calculating stepsizes - part ', num2str(k), '/', num2str(size(obj.Traces, 1))));
                            currPart = currMov{i};
                        
                            coordinates = [currPart.col, currPart.row, currPart.z];
                            CM = mean(coordinates,1);
                            coordinates = coordinates-CM;
                        
                            %in X
                            coord = coordinates(:,1)/10^3;
                            Dimension = '1D';
                            [allRes(i).StepSizes_x] = obj.GetStepSizes(coord);

                            %in Y
                            coord = coordinates(:,2)/10^3;
                            Dimension = '1D';
                            [allRes(i).StepSizes_y] = obj.GetStepSizes(coord);
                            
                            %inZ
                            if strcmp(obj.info.Dimension, '3D')
                                coord = coordinates(:,3)/10^3;
                                Dimension = '1D';
                                [allRes(i).StepSizes_z] = obj.GetStepSizes(coord);
                            end
    
                            %inR
                            if strcmp(obj.info.Dimension, '3D')
                                coord = coordinates(:,1:3)/10^3;
                                Dimension = '3D';
                            elseif strcmp(obj.info.Dimension, '2D')
                                coord = coordinates(:,1:2)/10^3;
                                Dimension = '2D';
                            end          
                            [allRes(i).StepSizes_r] = obj.GetStepSizes(coord);
                    
                            if all(size(AllStepSizes) == [0 0])
                                AllStepSizes = [AllStepSizes; allRes(i).StepSizes_r];
                            elseif size(AllStepSizes, 2) > size(allRes(i).StepSizes_r, 2)
                                ToAdd = [allRes(i).StepSizes_r, nan(size(allRes(i).StepSizes_r,1), size(AllStepSizes, 2) - size(allRes(i).StepSizes_r, 2))];
                                AllStepSizes = [AllStepSizes; ToAdd];
                            elseif size(AllStepSizes, 2) < size(allRes(i).StepSizes_r, 2)
                                ToAdd = [AllStepSizes, nan(size(AllStepSizes,1), size(allRes(i).StepSizes_r, 2) - size(AllStepSizes, 2))];
                                AllStepSizes = [ToAdd; allRes(i).StepSizes_r];
                            else
                                AllStepSizes = [AllStepSizes; allRes(i).StepSizes_r];
                            end
                        end
 
                        TimeResults.AllStepSizes{k} = AllStepSizes;
                    else
                        TimeResults.Time(k) = k;
                    end
    
                    Results{k,1} = allRes;
                end
                obj.Results{Loop, 1} = Results;
                filename = append(obj.raw.Path, filesep, 'msdRes_stepsizeAnalysis', num2str(Loop), '.mat');
                save(filename, "Results");
                Results{end,2} = TimeResults;
                obj.Results{Loop, 1} = Results;
                filename = append(obj.raw.Path, filesep, 'msd_TimeResults_stepsizeAnalysis', num2str(Loop), '.mat');
                save(filename, "TimeResults");
            end

            dt = obj.info.expTime;
            nRows = size(obj.Traces, 1);
            nI = numel(nRows);   
            Kmax = 3;           

            OutputFolder = append(obj.raw.Path, filesep, 'ecdf_fits_channel', num2str(Loop));
            mkdir(OutputFolder);

            f = waitbar(0, 'Initializing');
            for K = 1:3
                OutputFolder2 = append(OutputFolder, filesep, 'FitPopulations', num2str(K));
                mkdir(OutputFolder2);

                I = nan([size(Results{end, 2}.AllStepSizes, 2),1]);
                BIC = nan([size(Results{end, 2}.AllStepSizes, 2),1]);
                D = nan([size(Results{end, 2}.AllStepSizes, 2),K]);
                w = nan([size(Results{end, 2}.AllStepSizes, 2),K]);
                N = nan([size(Results{end, 2}.AllStepSizes, 2),1]);

                for i = 1:size(Results{end, 2}.AllStepSizes, 2)
                    try
                        waitbar(i./nI, f, append('fitting ecdf - part ', num2str(i), ' out of ', num2str(nI)));
                        r = Results{end, 2}.AllStepSizes{1,i}(:,1)';
                        if Loop == 1
                            r(r > 0.750) = [];
                        elseif Loop == 2
                            r(r > 0.450) = [];
                        end
                        r(isnan(r)) = [];
                        r = rmoutliers(r);
                        N(i,:) = numel(r);
                        [r_sorted, idx] = sort(r);
                        F_emp = (1:N(i,:))'/N(i,:);
                    
                        s = r.^2;
                        k_shape = 3/2;
    
                        gamma_pdf = @(s,theta) (1./(gamma(k_shape)*theta.^k_shape)) .* s.^(k_shape-1) .* exp(-s./theta);
                        models = struct();

                        [theta, w(i,:), logL] = obj.EM_gamma_fixedshape(s, K, 200);
                    
                        numParams = (K-1) + K; % weights + theta
                        BIC(i,1) = -2*logL(end) + numParams*log(N(i,:));
                        D(i,:) = theta ./ (4*dt);
    
                        F_mix = zeros(size(r_sorted));
                        for j = 1:K
                            F_mix = F_mix + w(i,:) * gammainc(r_sorted.^2 ./ theta, 3/2);
                        end
                        F_mix = F_mix./K;
    
                        if mod(i, 100) == 0
                            Fig = figure;
                            plot(r_sorted, F_emp, 'k.', 'DisplayName', 'Empirical');
                            hold on;
                            plot(r_sorted, F_mix, 'b-', 'LineWidth', 2, ...
                                'DisplayName', sprintf('%d-pop mixture', K));
                            xlabel('Step size r');
                            ylabel('CDF');
                            title(append('cdf fit - ', num2str(K), ' populations, timepoint ', num2str(i)))
                            grid on;
                            saveas(Fig, append(OutputFolder2, filesep, 'TimePoint', num2str(i), '.svg'));
                            saveas(Fig, append(OutputFolder2, filesep, 'TimePoint', num2str(i), '.svg'));
                        end
                        I(i, 1) = i*obj.info.expTime + TimeStamp*60;
                    catch
                        I(i, 1) = i*obj.info.expTime + TimeStamp*60;
                        BIC(i,1) = nan([1,1]);
                        D(i,1:K) = nan([1,K]);
                        w(i,1:K) = nan([1,K]);
                        N(i,1) = nan([1,1]);
                    end
                end

                FitResults.I = I;
                FitResults.BIC(:,K) = BIC;
                FitResults.N = N;
                if K == 1
                    FitResults.D(:,1) = D;
                    FitResults.fractions(:,1) = w;
                elseif K == 2
                    FitResults.D(:,2:3) = D;
                    FitResults.fractions(:,2:3) = w;
                elseif K == 3
                    FitResults.D(:,4:6) = D;
                    FitResults.fractions(:,4:6) = w;
                end
                close all

                colors = lines(Kmax);
                Fig = figure; 
                hold on;
                Time = FitResults.I;
                for Pop = 1:K
                    Dk = FitResults.D(:,Pop);
                    ak = FitResults.fractions(:,Pop);
                    scatter(Time,  Dk, 'filled', 'MarkerFaceAlpha', 'flat', 'AlphaData', ak);
                    plot(Time,  medfilt1(Dk, 50), 'Color', 'k', 'LineWidth', 2)
                end
                title(append('Diffusion ', num2str(K), ' populations'))
                xlabel('Polymerisation Time (s)')
                ylabel('Diffusion coefficient (µm^2/s)')
                saveas(Fig, append(OutputFolder2, filesep, 'DiffusionTrend.png'))
                saveas(Fig, append(OutputFolder2, filesep, 'DiffusionTrend.svg'))
            end
            close(f);

            [~, SelectPopRaw] = min(FitResults.BIC, [], 2);
            SelectPop = SelectPopRaw;
            SelectPop(SelectPop == 3) = 2;
            SelectPop = round(medfilt1(SelectPop,50));
            Start2Pop = find(SelectPop == 2, 1, 'first');
            Start2PopTime = Time(Start2Pop);

            Fig2 = figure();
            subplot(2,1,1)
            plot(Time, FitResults.BIC)
            ylabel('BIC score per population')
            xlabel('Polymerisation Time (s)')
            legend({'1-num Pop', '2-num Pop', '3-num Pop'}, 'Location', 'Best')
            subplot(2,1,2)
            scatter(Time, SelectPopRaw, 1, 'color', 'b', 'MarkerFaceAlpha', 0.3);
            hold on
            plot(Time, SelectPop, 'Color', 'k');
            ylim([0 4])
            ylabel('Population of preference')
            xlabel('Polymerisation Time (s)')
            sgtitle('Evaluation of population fits')
            saveas(Fig2, append(OutputFolder, filesep, 'FitEvaluations.png'))
            saveas(Fig2, append(OutputFolder, filesep, 'FitEvaluations.png'))

            ToPlot(1:Start2Pop, 1) = FitResults.D(1:Start2Pop, 1);
            ToPlot(1:Start2Pop, 2) = nan([Start2Pop, 1]);
            ToPlot(Start2Pop:size(FitResults.D, 1), 1:2) = fliplr(FitResults.D(Start2Pop:end, 2:3));
            Alpha(1:Start2Pop, 1) = ones([Start2Pop, 1]);
            Alpha(1:Start2Pop, 2) = zeros([Start2Pop, 1]);
            Alpha(Start2Pop:size(FitResults.D, 1), 1:2) = fliplr(FitResults.fractions(Start2Pop:end, 2:3));
            Alpha(isnan(Alpha)) = 0;

            Fig3 = figure;
            hold on
            subplot(5,1, [1,3])
            for Pop = 1:size(ToPlot, 2)
                scatter(FitResults.I, ToPlot(:,Pop), 5, 'filled', 'MarkerFaceAlpha', 'flat', 'AlphaData', Alpha(:,Pop));
                LegendNames{Pop} = append('Population ', num2str(Pop));
                hold on
            end
            ylabel('Diffusion coefficient (µm^2/s)');
            xline(Start2PopTime);
            legend(LegendNames);
            title('Diffusion trend')
            hold on
            subplot(5,1,4)
            for Pop = 1:size(ToPlot, 2)
                plot(FitResults.I', Alpha(:,Pop));
                LegendNames{Pop} = append('Population ', num2str(Pop));
                hold on
            end
            ylabel('Fractions');         
            hold on
            subplot(5,1,5)
            plot(FitResults.I, FitResults.N)
            ylabel('Number of steps')
            xlabel('Polymerisation Time (s)')
            saveas(Fig3, append(OutputFolder, filesep, 'DiffusionTrend.png'))
            saveas(Fig3, append(OutputFolder, filesep, 'DiffusionTrend.svg'))


            %%%%
            model = @(p,x) p(1) + (p(2)-p(1))*exp(-p(3)*exp(p(4)*(x-p(5))));
            y_smooth = smoothdata(ToPlot(:,1), 'sgolay', 11);
            x = FitResults.I;
            a0 = min(y_smooth);
            b0 = max(y_smooth) - a0;
            c0 = 1;
            d0 = 1 / (max(x)-min(x));
            e0 = mean(x);
            p0 = [a0, b0, c0, d0, e0];
            lb = [-Inf, 0, 0, -Inf, min(x)];
            ub = [ Inf, Inf, Inf, Inf, max(x)];
            opts = optimoptions('lsqcurvefit', ...
                'Display','iter', ...
                'MaxFunctionEvaluations',5000, ...
                'FunctionTolerance',1e-12);
            p_fit = lsqcurvefit(model, p0, x, y_smooth, lb, ub, opts);
            y_fit = model(p_fit, x);
            Fig4 = figure;
            plot(x, y, '.', 'Color',[0.7 0.7 0.7]); hold on
            plot(x, y_fit, 'b', 'LineWidth',2)
            legend('Raw data','Fit')
            xlabel('Polymerisation time (s)')
            ylabel('Diffusion coefficient (µm^2/s)')
            title('Gompertz fit - Fast diffusion fraction')
            saveas(Fig4, append(OutputFolder, filesep, 'FitFastDiff.png'))
            saveas(Fig4, append(OutputFolder, filesep, 'FitFastDiff.svg'))

            FitResults.Start2Pop = Start2PopTime;
            FitResults.BIC = array2table(FitResults.BIC, 'VariableNames', {'Pop1','Pop2','Pop3'});
            FitResults.D = array2table(FitResults.D, 'VariableNames', {'Pop1', 'Pop2_1','Pop2_2','Pop3_1','Pop3_2','Pop3_3'});
            FitResults.fractions = array2table(FitResults.fractions, 'VariableNames', {'Pop1','Pop2_1','Pop2_2', 'Pop3_1','Pop3_2','Pop3_3'});
            FitResults.Fit = array2table(p_fit, 'VariableNames', {'Base','Height','slope1', 'slope2','Inflection point'});

            obj.ResultsStepsize = FitResults;
            save(append(obj.raw.Path, filesep, 'StepSizeResults_Channel', num2str(Loop), '.mat'), "FitResults");
        end

        function [theta, w, logL] = EM_gamma_fixedshape(obj, s, K, maxIter)
            k_shape = 3/2;
            N = numel(s);

            theta = linspace(min(s), max(s), K)' / k_shape;
            w = ones(K,1)/K;
        
            logL = zeros(maxIter,1);
        
            for iter = 1:maxIter
                resp = zeros(N,K);
                for j = 1:K
                    resp(:,j) = w(j) * ...
                        (1./(gamma(k_shape)*theta(j)^k_shape)) .* ...
                        s.^(k_shape-1) .* exp(-s./theta(j));
                end
                resp = resp ./ sum(resp,2);

                w = mean(resp,1)';
                for j = 1:K
                    theta(j) = sum(resp(:,j).*s') / (k_shape*sum(resp(:,j)));
                end

                ll = 0;
                for j = 1:K
                    ll = ll + w(j) * ...
                        (1./(gamma(k_shape)*theta(j)^k_shape)) .* ...
                        s.^(k_shape-1) .* exp(-s./theta(j));
                end
                logL(iter) = sum(log(ll));
        
                if iter > 2 && abs(logL(iter)-logL(iter-1)) < 1e-6
                    logL = logL(1:iter);
                    break;
                end
            end
        end

    end
end

