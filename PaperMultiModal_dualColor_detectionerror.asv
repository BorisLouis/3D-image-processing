%% dualcolor_align_and_analyze.m
% Usage: edit rootFolder below if needed, then run.
% Outputs: printed mean/std (before/after), and two 3D plots for a chosen trace.
% Requires: standard MATLAB (no extra toolboxes). If you have the Statistics
% Toolbox you can speed up knn searches, but code uses basic knnsearch if available.

clear; close all; clc;

%% -------------------- User settings --------------------
rootFolder = 'S:\Dual Color\20250121_dualcolor\Multicolor_particles\In_water';
samplePattern = '0_min*';  % matches '0_min1', '0_min2', ...
calibNames = {'calibrated1','calibrated2'}; % channel folder names
maxInitialPairDist = 1000;  % large acceptance for initial NN pairing (units of your coordinates)
ransacIters = 1000;        % RANSAC iterations
ransacInlierTol = 5;       % inlier threshold (units), used for final inlier selection
minTraceCommon = 50;       % minimum overlap for choosing a trace pair (job 2)
rng(1);                    % reproducibility for RANSAC sampling
%% -------------------------------------------------------

%% helper: load SRList from particle.mat -> Nx4 matrix [x y z t]
function pts = load_particle_SRlist(particleMatPath)
    s = load(particleMatPath, 'particle');
    if ~isfield(s,'particle')
        error('No variable ''particle'' found in %s', particleMatPath);
    end
    p = s.particle;
    if ~isfield(p,'SRList')
        error('particle.SRList not found in %s', particleMatPath);
    end
    SR = p.SRList; % n x 10 table or array
    % handle table or numeric array
    if istable(SR)
        row = SR{:,1}; col = SR{:,2}; z = SR{:,3}; t = SR{:,10};
    else
        row = SR(:,1); col = SR(:,2); z = SR(:,3); t = SR(:,10);
    end
    % convert to x,y = col,row per your description
    x = col; y = row;
    pts = [x(:), y(:), z(:), t(:)];
end

%% helper: Umeyama similarity (compute s,R,t mapping X->Y)
% X and Y are Nx3 corresponding points
function [s, R, tvec] = umeyama_similarity(X, Y, estimate_scale)
    % X, Y: NxD
    if nargin < 3, estimate_scale = true; end
    [N, D] = size(X);
    muX = mean(X,1);
    muY = mean(Y,1);
    Xc = X - muX;
    Yc = Y - muY;
    Sigma = (Yc' * Xc) / N;
    [U, Smat, V] = svd(Sigma);
    Sdiag = ones(D,1);
    if det(U)*det(V) < 0
        Sdiag(end) = -1;
    end
    M = eye(D);
    M(end,end) = Sdiag(end);
    R = U * M * V';
    if estimate_scale
        varX = sum(sum(Xc.^2,2)) / N;
        s = trace(Smat * M) / varX;
    else
        s = 1;
    end
    tvec = muY' - s * R * muX';
end

%% Gather data across all samples and channels:
sampleDirs = dir(fullfile(rootFolder, samplePattern));
if isempty(sampleDirs)
    error('No sample folders found in %s with pattern %s', rootFolder, samplePattern);
end

allPairs = []; % will hold candidate correspondences across all samples: [x1 y1 z1 x2 y2 z2 t sampleIdx]
fprintf('Scanning %d sample folders...\n', numel(sampleDirs));
sampleIdx = 0;
h = waitbar(0, 'initializing');
for sd = 1:numel(sampleDirs)
    waitbar(sd./numel(sampleDirs), h, append('calculating pairs: frame ', num2str(sd), ' out of ', num2str(numel(sampleDirs))))
    sampleName = sampleDirs(sd).name;
    samplePath = fullfile(rootFolder, sampleName);
    % check both calibrated folders exist
    c1 = fullfile(samplePath, append('data_', samplePath(end)), calibNames{1}, 'particle.mat');
    c2 = fullfile(samplePath, append('data_', samplePath(end)), calibNames{2}, 'particle.mat');
    if exist(c1,'file') && exist(c2,'file')
        sampleIdx = sampleIdx + 1;
        pts1 = load_particle_SRlist(c1); % Nx4 [x y z t]
        pts2 = load_particle_SRlist(c2);
        % For each frame/time t that appears in both, produce tentative pairings by NN within frame:
        t1set = unique(pts1(:,4));
        t2set = unique(pts2(:,4));
        commonT = intersect(t1set, t2set);
        for ti = 1:numel(commonT)
            tval = commonT(ti);
            idx1 = find(pts1(:,4) == tval);
            idx2 = find(pts2(:,4) == tval);
            P1 = pts1(idx1,1:3);
            P2 = pts2(idx2,1:3);
            if isempty(P1) || isempty(P2), continue; end
            % use knnsearch if available otherwise brute-force
            if exist('knnsearch','file') && size(P2,1) >= size(P1,1)
                [inds, dists] = knnsearch(P2, P1); % for each P1 find nearest in P2
                for k = 1:numel(inds)
                    if dists(k) <= maxInitialPairDist
                        pair = [P1(k,:), P2(inds(k),:), tval, sampleIdx];
                        allPairs = [allPairs; pair];
                    end
                end
            else
                % brute force nearest:
                for i1 = 1:size(P1,1)
                    diffs = P2 - P1(i1,:);
                    dists = sqrt(sum(diffs.^2,2));
                    [mind, idxmin] = min(dists);
                    if mind <= maxInitialPairDist
                        pair = [P1(i1,:), P2(idxmin,:), tval, sampleIdx];
                        allPairs = [allPairs; pair];
                    end
                end
            end
        end
    else
        warning('Missing particle.mat in sample %s (expected %s and %s)', sampleName, c1, c2);
    end
end
close(h)

if isempty(allPairs)
    error('No tentative pairs found. Check paths and SRList contents.');
end

fprintf('Collected %d tentative point-to-point pairs (across all samples & frames).\n', size(allPairs,1));

%% Run RANSAC + Umeyama similarity to find robust mapping ch2 -> ch1
X = allPairs(:,4:6); % points in channel2 (target to transform)
Y = allPairs(:,1:3); % corresponding points in channel1

bestInliers = [];
bestModel = struct('s',[],'R',[],'t',[]);
Npairs = size(X,1);
minSample = 3; % need at least 3 correspondences for 3D similarity
for iter = 1:ransacIters
    % sample minimal subset
    idx = randperm(Npairs, min(minSample, Npairs));
    Xs = X(idx,:);
    Ys = Y(idx,:);
    try
        [s_est, R_est, t_est] = umeyama_similarity(Xs, Ys, true);
    catch
        continue;
    end
    % compute residuals for all pairs
    Xtrans = (s_est * (R_est * X') + t_est)';
    diffs = Y - Xtrans;
    res = sqrt(sum(diffs.^2,2));
    inliers = find(res <= ransacInlierTol);
    if numel(inliers) > numel(bestInliers)
        bestInliers = inliers;
        bestModel.s = s_est;
        bestModel.R = R_est;
        bestModel.t = t_est;
    end
end

% If RANSAC found no good inliers, fall back to using all pairs with Umeyama (robust will be poor)
if isempty(bestInliers)
    warning('RANSAC found no inliers under current threshold. Falling back to Umeyama on all tentative pairs.');
    [s_all, R_all, t_all] = umeyama_similarity(X, Y, true);
    bestModel.s = s_all; bestModel.R = R_all; bestModel.t = t_all;
    inlierIdx = 1:Npairs;
else
    % refine model on all inliers
    Xi = X(bestInliers,:);
    Yi = Y(bestInliers,:);
    [s_ref, R_ref, t_ref] = umeyama_similarity(Xi, Yi, true);
    bestModel.s = s_ref; bestModel.R = R_ref; bestModel.t = t_ref;
    inlierIdx = bestInliers;
end

fprintf('RANSAC inliers: %d / %d pairs used to estimate transform.\n', numel(inlierIdx), Npairs);

%% compute mismatch statistics BEFORE transform (using only matched pairs that were used as inliers)
X_used = X(inlierIdx,:);
Y_used = Y(inlierIdx,:);
Xtrans_initial = X_used; % before correction
diffs_before = Y_used - Xtrans_initial; % per-axis (x,y,z)
dists_before_3d = sqrt(sum(diffs_before.^2,2));
mean_before_3d = mean(dists_before_3d);
std_before_3d = std(dists_before_3d);
mean_before_axis = mean(diffs_before,1);
std_before_axis = std(diffs_before,[],1);

%% apply found transform to all channel2 points (allPairs and later on trackResults)
s = bestModel.s; R = bestModel.R; tvec = bestModel.t;
% function to apply:
apply_transform = @(Pts) (s * (R * Pts') + tvec)'; % Pts Nx3

X_used_transformed = apply_transform(X_used);
diffs_after = Y_used - X_used_transformed;
dists_after_3d = sqrt(sum(diffs_after.^2,2));
mean_after_3d = mean(dists_after_3d);
std_after_3d = std(dists_after_3d);
mean_after_axis = mean(diffs_after,1);
std_after_axis = std(diffs_after,[],1);

%% Print results
fprintf('\n--- Mismatch statistics (using robust matched pairs) ---\n');
fprintf('Before correction: 3D mean distance = %.4f   std = %.4f\n', mean_before_3d, std_before_3d);
fprintf('  Axis means (x,y,z) = [%.4f, %.4f, %.4f]\n', mean_before_axis);
fprintf('  Axis std   (x,y,z) = [%.4f, %.4f, %.4f]\n', std_before_axis);
fprintf('After correction:  3D mean distance = %.4f   std = %.4f\n', mean_after_3d, std_after_3d);
fprintf('  Axis means (x,y,z) = [%.4f, %.4f, %.4f]\n', mean_after_axis);
fprintf('  Axis std   (x,y,z) = [%.4f, %.4f, %.4f]\n\n', std_after_axis);

fprintf('Estimated 3D similarity transform (ch2 -> ch1):\n');
fprintf('  scale s = %.6f\n', s);
fprintf('  rotation R = \n'); disp(R);
fprintf('  translation t = [%.6f %.6f %.6f]''\n', tvec);

%% ----------------- Job 2: find trace-pair with >50 common detections -----------------
fprintf('Searching for a pair of traces with >%d common detections...\n', minTraceCommon);

% Re-scan sample folders again for trackResults files to find traces
bestTracePair = struct('sample',[],'i1',[],'i2',[],'common',0,'timeFrames',[],'coords1',[],'coords2uncorr',[],'coords2corr',[]);
for sd = 1:numel(sampleDirs)
    sampleName = sampleDirs(sd).name;
    samplePath = fullfile(rootFolder, sampleName);
    tr1file = fullfile(samplePath, 'trackResults1.mat');
    tr2file = fullfile(samplePath, 'trackResults2.mat');
    if ~(exist(tr1file,'file') && exist(tr2file,'file')), continue; end
    d1 = load(tr1file, 'trackRes');
    d2 = load(tr2file, 'trackRes');
    if ~isfield(d1,'trackRes') || ~isfield(d2,'trackRes'), continue; end
    tr1 = d1.trackRes;
    tr2 = d2.trackRes;
    if ~isfield(tr1,'traces') || ~isfield(tr2,'traces'), continue; end
    traces1 = tr1.traces; % m x 8 cell; column 1 contains l x 12 tables
    traces2 = tr2.traces;
    m1 = size(traces1,1);
    m2 = size(traces2,1);
    % Pre-extract for speed: build cell arrays of Nx4 per trace: [x y z t]
    traceCoords1 = cell(m1,1);
    for i = 1:m1
        tab = traces1{i,1}; % l x 12 table
        if istable(tab)
            row = tab{:,1}; col = tab{:,2}; z = tab{:,3}; t = tab{:,10};
        else
            row = tab(:,1); col = tab(:,2); z = tab(:,3); t = tab(:,10);
        end
        x = col; y = row;
        traceCoords1{i} = [x(:), y(:), z(:), t(:)];
    end
    traceCoords2 = cell(m2,1);
    for j = 1:m2
        tab = traces2{j,1};
        if istable(tab)
            row = tab{:,1}; col = tab{:,2}; z = tab{:,3}; t = tab{:,10};
        else
            row = tab(:,1); col = tab(:,2); z = tab(:,3); t = tab(:,10);
        end
        x = col; y = row;
        traceCoords2{j} = [x(:), y(:), z(:), t(:)];
    end
    % Compare all pairs (can be expensive; hope m1*m2 manageable). We'll use time-based join.
    for i = 1:m1
        coords1 = traceCoords1{i};
        if isempty(coords1), continue; end
        times1 = coords1(:,4);
        for j = 1:m2
            coords2 = traceCoords2{j};
            if isempty(coords2), continue; end
            % find common times
            [commonTimes, ia, ib] = intersect(times1, coords2(:,4));
            if numel(commonTimes) <= minTraceCommon, continue; end
            % compare positions at those times
            P1 = coords1(ia,1:3);
            P2 = coords2(ib,1:3);
            % apply transform to P2
            P2corr = apply_transform(P2);
            dists = sqrt(sum((P1 - P2corr).^2,2));
            % count frames where corrected distance small enough (use 5 units)
            % BUT the user asked to find traces that have >50 common detection in both channels
            % (we already ensured times overlapping >50). Optionally also require many close after transform.
            closeCount = sum(dists <= ransacInlierTol);
            if closeCount > bestTracePair.common
                bestTracePair.sample = sampleName;
                bestTracePair.i1 = i;
                bestTracePair.i2 = j;
                bestTracePair.common = numel(commonTimes);
                bestTracePair.timeFrames = commonTimes;
                bestTracePair.coords1 = P1;
                bestTracePair.coords2uncorr = P2;
                bestTracePair.coords2corr = P2corr;
            end
        end
    end
end

if isempty(bestTracePair.sample)
    warning('No trace pair found with >%d overlapping timepoints. Lower minTraceCommon to attempt a match.', minTraceCommon);
else
    fprintf('Found best trace pair in sample %s: trace1 #%d vs trace2 #%d with %d overlapping frames.\n', ...
        bestTracePair.sample, bestTracePair.i1, bestTracePair.i2, bestTracePair.common);
end

%% Plot the chosen trace pair: before correction (ch1 green, ch2 uncorrected red)
if ~isempty(bestTracePair.sample)
    P1 = bestTracePair.coords1;
    P2u = bestTracePair.coords2uncorr;
    P2c = bestTracePair.coords2corr;
    % Plot 1: uncorrected
    figure('Name','Trace overlay — before correction','NumberTitle','off');
    plot3(P1(:,1), P1(:,2), P1(:,3), '-o', 'Color',[0 0.6 0], 'LineWidth',1.5, 'MarkerSize',4); hold on;
    plot3(P2u(:,1), P2u(:,2), P2u(:,3), '-o', 'Color',[1 0 0], 'LineWidth',1.2, 'MarkerSize',4);
    xlabel('x'); ylabel('y'); zlabel('z');
    title(sprintf('Sample %s: trace %d — ch1 (green) vs ch2 uncorrected (red)', bestTracePair.sample, bestTracePair.i1));
    legend('channel 1','channel 2 uncorrected','Location','best');
    grid on; axis equal; view(3);
    % Plot 2: corrected
    figure('Name','Trace overlay — after correction','NumberTitle','off');
    plot3(P1(:,1), P1(:,2), P1(:,3), '-o', 'Color',[0 0.6 0], 'LineWidth',1.5, 'MarkerSize',4); hold on;
    plot3(P2c(:,1), P2c(:,2), P2c(:,3), '-o', 'Color',[1 0 0], 'LineWidth',1.2, 'MarkerSize',4);
    xlabel('x'); ylabel('y'); zlabel('z');
    title(sprintf('Sample %s: trace %d — ch1 (green) vs ch2 corrected (red)', bestTracePair.sample, bestTracePair.i1));
    legend('channel 1','channel 2 corrected','Location','best');
    grid on; axis equal; view(3);
end

%% Final summary printed again in a structured way:
fprintf('\nFINAL SUMMARY:\n');
fprintf('Pairs used to calculate stats: %d\n', numel(inlierIdx));
fprintf('Before correction: mean 3D = %.4f, std = %.4f\n', mean_before_3d, std_before_3d);
fprintf('After  correction: mean 3D = %.4f, std = %.4f\n', mean_after_3d, std_after_3d);
fprintf('Axis means before: [%.4f %.4f %.4f], after: [%.4f %.4f %.4f]\n', ...
    mean_before_axis, mean_after_axis);
fprintf('Axis stds  before: [%.4f %.4f %.4f], after: [%.4f %.4f %.4f]\n', ...
    std_before_axis, std_after_axis);

%% Save results (optional)
% Uncomment to save numeric summary
% save('dualcolor_alignment_summary.mat', 'bestModel', 'inlierIdx', 'mean_before_3d', 'std_before_3d', ...
%     'mean_after_3d', 'std_after_3d', 'mean_before_axis', 'std_before_axis', ...
%     'mean_after_axis', 'std_after_axis', 'bestTracePair');

fprintf('Done.\n');