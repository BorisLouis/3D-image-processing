classdef MPTICSMovie < Core.MPMovie
    %MPTICSMOVIE Summary of this class goes here
    %   Detailed explanation goes here
    
    properties
        AllFrames
        Omegas
        AutocorrMap
        FitResults
        Diffusionmap
    end
    
    methods
        function obj = MPTICSMovie(raw,cal,info)
            
            obj  = obj@Core.MPMovie(raw,cal,info);
        end
        
        function LoadAllFrames(obj)
            h = waitbar(0, 'initializing');
            for c = 1:obj.calibrated{1, 1}.nPlanes
                waitbar(c./(obj.calibrated{1, 1}.nPlanes), h, append('Loading plane ', num2str(c), '/', num2str(obj.calibrated{1, 1}.nPlanes)));
                Path = append(obj.calibrated{1, 1}.mainPath, filesep, 'calibratedPlane', num2str(c), '.tif');
                if strcmp(obj.info.frame2Load, 'all')
                    obj.AllFrames{c, 1} = Load.Movie.tif.getframes(Path, 1:obj.raw.maxFrame);
                else
                    Load.movie.tif.getframes(obj.calibrated{1, 1}.mainPath, obj.info.frame2Load);
                end
            end
            close(h)
        end

        function calculateOmega(obj)
            h = waitbar(0, 'initializing');
            for c = 1:obj.calibrated{1, 1}.nPlanes
                Movie = obj.AllFrames{c,1};
                MaxFrame = 50; %size(obj.AllFrames, 3)
                for frame = 1:MaxFrame
                    waitbar(frame./MaxFrame, h, append('calc sacf frame ', num2str(frame), '/',...
                            num2str(MaxFrame), ' - Plane ', num2str(c)));
                    Frame = Movie(:,:,frame);
                    sacf = obj.SACF(Frame);
                    List(frame) = obj.fitSACF(sacf,0)*obj.info.PxSize;
                end
                Results.wList = List;
                Results.wAvg = mean(List);
                obj.Omegas{c,1} = Results;
            end
            close(h)
        end

        function getAutocorrmap(obj)
            h = waitbar(0, 'initializing');
            for c = 1:obj.calibrated{1, 1}.nPlanes
                [rows, cols, nLags] = size(obj.AllFrames{c, 1});
                autoCorr = zeros(rows, cols, nLags, 'single');
                TACFMatrix = nan(rows, cols);
                frames = obj.AllFrames{c,1};
                n = 0;
                for i = 1:rows
                    for j = 1:cols   
                        n = n+1;
                        waitbar(n./(rows*cols), h, append('computing TACF plane ', num2str(c))) ;
                        ts = double(squeeze(frames(i,j,:)));
                        ts = ts - mean(ts, 'omitnan');
                        tsTrend = medfilt1(ts, 150);
                        ts = ts - tsTrend;
                        [ac] = obj.TACF(ts);
                        TACS_Matrix(i, j,:) = ac;
                    end
                end
            end
            close(h)
            obj.AutocorrMap = TACS_Matrix;
        end

        function getDiffusionmap(obj)
            tic
            hh = waitbar(0, 'initializing');
            Tau = [0, (1:size(AutoCorr,1)).*obj.info.ExpTime]';
            Tau(end) = [];
            FitRange = 10;
            for c = 1:obj.calibrated{1, 1}.nPlanes
                C     = obj.Omegas{1, 1}.wAvg*10^(-6);               % your fixed C
                data = obj.AutocorrMap;
                blockSize = obj.info.TICSWindow;

                newX = floor(size(data,1)/blockSize);
                newY = floor(size(data,2)/blockSize); 

                B = mean(reshape(data(1:newX*blockSize, 1:newY*blockSize, :), ...
                                 blockSize, newX, blockSize, newY, size(data,3)), [1 3]);
                data = squeeze(B);

                n = 0;
                rows = size(data, 1);
                cols = size(data, 2);
                options = optimoptions('lsqcurvefit','Display','off');
                for i = 1:rows
                    for j = 1:cols
                        n = n+1;
                        waitbar(n./(rows*cols), hh, append('Fitting on TACF ', num2str(n), '/',...
                            num2str(rows*cols), ' - plane ', num2str(c)));
                        AutoCorr = squeeze(data(i,j,:)./max(data(i,j,:)));

                        f = fit(Tau, AutoCorr(:), '(1./(1+x/a))');
                        coeff = coeffvalues(f);
                        LifeTime = coeff(1);
                        

                        D = sqrt(C)./(4*LifeTime);
                        eta(i,j) = (1.380649*10^-23*296.15)./(6*pi*20*10^(-9)*D*10^(-12))*10^3;
                    end
                end
                
             
            end
            close(hh)
            toc
        end

        function sacf = SACF(obj, Frame)

            I = double(Frame);
            [ny, nx] = size(I);
            dI = I - mean(I(:));
            F = fft2(dI);
            R = ifft2(abs(F).^2);
            R = fftshift(R);
            mu = mean(I(:));
            sacf = R / (mu * mu);
        
        end

        function [tacf] = TACF(obj, IntTrace)
            x = IntTrace;       % e.g. x = squeeze(I(y,x,:))';
            T = length(x);
            
            % --- Step 1: temporal mean ---
            mu = mean(x);
            
            % --- Step 2: fluctuations ---
            dx = x - mu;
            
            % --- Prepare outputs ---
            maxTau = T-1;
            numerator = zeros(1, maxTau+1);
            denominator = mu * mu;   % stationary assumption (standard TICS)
            tacf = zeros(1, maxTau+1);
            
            % --- Steps 3â€“4: autocorrelation numerator and normalization ---
            for tau = 0:maxTau
                Nt = T - tau;                                  % valid pairs
                % numerator: <dx(t) dx(t+tau)>
                numerator(tau+1) = sum(dx(1:Nt) .* dx(1+tau:Nt+tau)) / Nt;
            
                % final correlation r(tau)
                tacf(tau+1) = numerator(tau+1) / denominator;
            end
        end

        function [omega] = fitSACF(obj, sacf, ToPlot)
            sacf(sacf < 0) = 0;
            r_map = sacf;
            [nx, ny] = size(sacf);
            cx = floor(nx/2) + 1;
            cy = floor(ny/2) + 1;
            
            [xi, eta] = meshgrid(1:ny, 1:nx);
            xi = xi - cy;     % shift to center at zero
            eta = eta - cx;
            
            rho = sqrt(xi.^2 + eta.^2);   % radial distance
            
            % -------------------------------------------------------------
            % 2. Flatten arrays for easier processing
            % -------------------------------------------------------------
            rho_vec = rho(:);
            r_vec   = r_map(:);
            
            % remove NaNs if present
            valid = ~isnan(r_vec);
            rho_vec = rho_vec(valid);
            r_vec   = r_vec(valid);
            
            % -------------------------------------------------------------
            % 3. Define radial bins
            % -------------------------------------------------------------
            dr = 1;   % bin width in pixels
            r_max = max(rho_vec);
            edges = 0:dr:r_max;
            bin_centers = edges(1:end-1) + dr/2;
            
            r_rad = zeros(size(bin_centers));
            N_bin = zeros(size(bin_centers));
            
            for k = 1:length(bin_centers)
                mask = (rho_vec >= edges(k)) & (rho_vec < edges(k+1));
                r_rad(k) = mean(r_vec(mask));
                N_bin(k) = sum(mask);
            end
            
            % Remove empty bins
            nonempty = N_bin > 0;
            rho_fit = bin_centers(nonempty);
            r_fit   = r_rad(nonempty);
            w       = sqrt(N_bin(nonempty));   % weights = sqrt(counts)
            
            % -------------------------------------------------------------
            % 4. Initial parameter estimates
            % -------------------------------------------------------------
            Ginf0 = mean(r_fit(end-3:end));             % asymptote guess
            G0_0  = r_fit(1) - Ginf0;                   % amplitude guess
            omega0_0 = rho_fit(find(r_fit <= Ginf0 + G0_0*exp(-1),1));
            if isempty(omega0_0)
                omega0_0 = 2;  % fallback guess
            end
            
            p0 = [G0_0, omega0_0, Ginf0];   % initial parameters
            
            % -------------------------------------------------------------
            % 5. Define model function
            % -------------------------------------------------------------
            model_fun = @(p, rho) p(1)*exp(-(rho.^2)/(p(2)^2)) + p(3);
            
            % -------------------------------------------------------------
            % 6. Perform nonlinear least squares fit (weighted)
            % -------------------------------------------------------------
            opts = optimoptions('lsqcurvefit','Display','off');
            
            lb = [-Inf, 0, -Inf];   % omega0 must be positive
            ub = [ Inf, Inf, Inf];
            
            p_fit = lsqcurvefit(@(p, rho) w .* model_fun(p,rho), ...
                                p0, rho_fit, w .* r_fit, lb, ub, opts);
            
            G0     = p_fit(1);
            omega  = p_fit(2);
            Ginf   = p_fit(3);
            
            if ToPlot == 1
                % -------------------------------------------------------------
                % 7. Plot results
                % -------------------------------------------------------------
                figure; hold on;
                plot(rho_fit, r_fit, 'ko', 'MarkerFaceColor','k','DisplayName','Radial Average');
                rho_plot = linspace(0, max(rho_fit), 200);
                plot(rho_plot, model_fun(p_fit, rho_plot), 'r-', 'LineWidth',2, ...
                     'DisplayName','Fit');
                
                xlabel('\rho (pixels)');
                ylabel('r(\rho)');
                legend();
                title(sprintf('Fit Result:  \\omega_0 = %.3f pixels', omega));
                grid on;
            end
        end
    end
end

